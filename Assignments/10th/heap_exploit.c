#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

/* Structure for heap analysis */
struct auth {
   char name[32];       // Name buffer
   char pass[32];       // Password buffer
   int privilege;       // Added privilege level
   void (*callback)();  // Added function pointer
} __attribute__((aligned(16)));

/* Target functions */
void normal_function() {
   printf("Normal user access\n");
}

void root_shell() {
   printf("Exploit successful - spawning shell\n");
   system("/bin/sh");
}

/* Global pointers for tracking */
struct auth *auth1 = NULL;
struct auth *auth2 = NULL;

/* Debug function for memory display */
void show_memory(void* ptr, size_t size) {
   unsigned char *p = (unsigned char*)ptr;
   printf("\nMemory at %p:\n", ptr);
   for(size_t i = 0; i < size; i += 16) {
       printf("%04lx: ", i);
       for(size_t j = 0; j < 16 && i+j < size; j++) {
           printf("%02x ", p[i+j]);
       }
       printf("\n");
   }
}

int main() {
   char choice[16] = {0};
   int running = 1;
   
   printf("Heap Structure Sizes:\n");
   printf("auth: %zu bytes\n", sizeof(struct auth));
   
   while(running) {
       printf("\nHeap Exploitation Menu:\n");
       printf("1. Create auth (small chunk)\n");
       printf("2. Create auth2 (small chunk)\n");
       printf("3. Free auth1\n");
       printf("4. Show memory\n");
       printf("5. Modify auth1\n");
       printf("6. Execute callback\n");
       printf("0. Exit\n");
       printf("Choice: ");
       
       if (fgets(choice, sizeof(choice), stdin) == NULL) {
           break;
       }
       
       switch(choice[0]) {
           case '1':
               if (!auth1) {
                   auth1 = malloc(sizeof(struct auth));
                   if (auth1) {
                       memset(auth1, 0, sizeof(struct auth));
                       printf("Enter name: ");
                       fgets(auth1->name, 32, stdin);
                       auth1->callback = normal_function;
                       printf("Auth1 created at: %p\n", (void*)auth1);
                       show_memory(auth1, sizeof(struct auth));
                   }
               }
               break;
               
           case '2':
               if (!auth2) {
                   auth2 = malloc(sizeof(struct auth));
                   if (auth2) {
                       memset(auth2, 0, sizeof(struct auth));
                       auth2->callback = normal_function;
                       printf("Auth2 created at: %p\n", (void*)auth2);
                       show_memory(auth2, sizeof(struct auth));
                   }
               }
               break;
               
           case '3':
               if(auth1) {
                   printf("Freeing auth1 at: %p\n", (void*)auth1);
                   free(auth1);
                   show_memory(auth1, sizeof(struct auth));
               }
               break;
               
           case '4':
               if(auth1) show_memory(auth1, sizeof(struct auth));
               if(auth2) show_memory(auth2, sizeof(struct auth));
               break;
               
           case '5':
               if(auth1) {
                   auth1->callback = root_shell;
                   printf("Modified auth1 callback\n");
                   show_memory(auth1, sizeof(struct auth));
               }
               break;
               
           case '6':
               if(auth1 && auth1->callback) {
                   printf("Executing auth1 callback\n");
                   auth1->callback();
               }
               break;
               
           case '0':
               running = 0;
               break;
       }
   }
   
   return 0;
}
